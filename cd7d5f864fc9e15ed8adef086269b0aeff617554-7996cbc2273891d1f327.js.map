{"version":3,"file":"cd7d5f864fc9e15ed8adef086269b0aeff617554-7996cbc2273891d1f327.js","mappings":"iYAA8M,SAASA,IAAI,OAAOA,EAAEC,OAAOC,OAAOD,OAAOC,OAAOC,OAAO,SAASC,GAAG,IAAI,IAAIC,EAAE,EAAEA,EAAEC,UAAUC,OAAOF,IAAI,CAAC,IAAIG,EAAEF,UAAUD,GAAG,IAAI,IAAII,KAAKD,EAAEP,OAAOS,UAAUC,eAAeC,KAAKJ,EAAEC,KAAKL,EAAEK,GAAGD,EAAEC,IAAI,OAAOL,GAAGJ,EAAEa,MAAM,KAAKP,WAAW,SAASQ,EAAEV,EAAEC,GAAG,GAAG,MAAMD,EAAE,MAAM,GAAG,IAAII,EAAEC,EAAEM,EAAE,GAAGC,EAAEf,OAAOgB,KAAKb,GAAG,IAAIK,EAAE,EAAEA,EAAEO,EAAET,OAAOE,IAAIJ,EAAEa,QAAQV,EAAEQ,EAAEP,KAAK,IAAIM,EAAEP,GAAGJ,EAAEI,IAAI,OAAOO,EAAmkL,IAAwII,EAAE,WAAD,MAAK,oBAAoBC,kBAAkB,YAAYA,iBAAiBV,WAA8hC,SAASW,EAAEjB,EAAEC,EAAEG,EAAEC,EAAEM,GAAM,YAAL,IAADA,IAAAA,EAAE,IAAwKf,EAAE,GAAGQ,EAAE,CAACc,QAAQb,EAAEc,WAAWnB,EAAE,kBAAkB,GAAGoB,MAAMxB,EAAE,GAAGe,EAAE,CAACU,QAAQpB,EAAE,EAAE,MAAM,SAASqB,EAAEtB,EAAEC,EAAEG,EAAEC,EAAEM,EAAEC,EAAEW,EAAEC,GAAG,IAAMC,EAAE,GAAGb,IAAIa,EAAEC,gBAAgBd,EAAE,UAAUR,GAAGqB,EAAEE,MAAMtB,EAAEoB,EAAEG,OAAOjB,EAAEc,EAAEC,gBAAgBd,EAAEa,EAAEI,SAAS,aAAa,gBAAgBzB,GAAG,cAAcA,KAAKqB,EAAEI,SAAS,WAAWJ,EAAEK,IAAI,EAAEL,EAAEM,KAAK,EAAEN,EAAEO,OAAO,EAAEP,EAAEQ,MAAM,IAAIV,IAAIE,EAAES,UAAUX,GAAGC,IAAIC,EAAEU,eAAeX,GAAG,IAAMY,EAAExC,EAAE,GAAGI,EAAE,CAAC,eAAc,EAAG,yBAAyB,GAAGoB,MAAMxB,EAAE,CAACyB,QAAQpB,EAAE,EAAE,EAAEoC,WAAW,wBAAwBZ,KAAK,OAAoFW,EAAm3B,IAAwxCE,EAAlxCC,EAAE,CAAC,YAAYC,EAAE,SAAD,GAAsC,IAApBvC,EAAC,EAARwC,OAAerC,EAAC,EAAPuB,MAAetB,EAAC,EAARuB,OAAW,MAAM,cAAc3B,EAAED,EAAAA,cAAgB,MAAM,CAAC,eAAc,EAAGoB,MAAM,CAACsB,WAAWrC,EAAED,EAAE,IAAI,OAAO,gBAAgBH,EAAED,EAAAA,cAAgB,MAAM,CAACoB,MAAM,CAACuB,SAASvC,EAAEwC,QAAQ,UAAU5C,EAAAA,cAAgB,MAAM,CAAC6C,IAAI,GAAGC,KAAK,eAAe,cAAc,OAAOC,IAAG,mDAAoD1C,EAAC,YAAYD,EAAC,kEAAkEgB,MAAM,CAACuB,SAAS,OAAOC,QAAQ,QAAQf,SAAS,aAAa,MAAMmB,EAAE,SAAS5C,GAAM,IAAUC,EAAGD,EAAZ6C,SAActC,EAAED,EAAEN,EAAEmC,GAAG,OAAOvC,EAAAA,cAAgBC,EAAAA,SAAE,KAAKD,EAAAA,cAAgBwC,EAAE5C,EAAE,GAAGe,IAAIN,EAAE,OAAO6C,EAAE,CAAC,MAAM,SAAS,UAAU,MAAM,cAAcC,EAAE,CAAC,WAAW,UAAU,cAAcC,EAAE,SAASnD,GAAG,IAAQG,EAA4CH,EAAhD8C,IAAa1C,EAAmCJ,EAA1CoD,OAAiB1C,EAAyBV,EAAjCiB,QAAO,EAA0BjB,EAAvB4C,IAAIjC,OAAC,MAAC,GAAE,EAAYW,EAAGtB,EAAdkB,WAAgBK,EAAEd,EAAET,EAAEiD,GAAG,OAAOlD,EAAAA,cAAgB,MAAMJ,EAAE,GAAG4B,EAAE,CAAC8B,SAAS,QAAQpC,QAAQP,EAAEoC,IAAIxB,EAAEnB,OAAE,EAAO,WAAWmB,OAAE,EAAOnB,EAAEiD,OAAO9B,EAAElB,OAAE,EAAO,cAAckB,OAAE,EAAOlB,EAAEwC,IAAIjC,MAAM2C,EAAE,SAAStD,GAAG,IAAaG,EAAgCH,EAAzCuD,SAAQ,EAAiCvD,EAA9BwD,QAAQpD,OAAC,MAAC,GAAE,IAAkBJ,EAAjBkB,WAAWR,OAAC,OAAG,EAAIC,EAAEF,EAAET,EAAEkD,GAAS5B,EAAEX,EAAE8C,QAAQ,MAAMtD,OAAE,EAAOA,EAAEsD,OAAOlC,EAAExB,EAAAA,cAAgBoD,EAAExD,EAAE,GAAGgB,EAAER,EAAE,CAACsD,MAAMnC,EAAEJ,WAAWR,KAAK,OAAON,EAAEF,OAAOH,EAAAA,cAAgB,UAAU,KAAKK,EAAEsD,KAAI,gBAAQ1D,EAAC,EAAP2D,MAAexD,EAAC,EAARiD,OAAchD,EAAC,EAANwD,KAAI,OAAM7D,EAAAA,cAAgB,SAAS,CAAC8D,IAAO7D,EAAC,IAAII,EAAC,IAAID,EAAIyD,KAAKxD,EAAEuD,MAAM3D,EAAEoD,OAAO1C,EAAEP,OAAE,EAAO,cAAcO,OAAE,EAAOP,EAAEsD,MAAMnC,OAAKC,GAAGA,GAAS4B,EAAEW,UAAU,CAAChB,IAAIX,EAAAA,OAAAA,WAAoBS,IAAIT,EAAAA,OAAAA,WAAoBsB,MAAMtB,EAAAA,OAASiB,OAAOjB,EAAAA,OAASjB,WAAWiB,EAAAA,MAAQmB,EAAES,YAAY,UAAUT,EAAEQ,UAAU,CAAClB,IAAIT,EAAAA,OAAAA,WAAoBjB,WAAWiB,EAAAA,KAAOoB,SAASpB,EAAAA,MAAQ,CAACW,IAAIX,EAAAA,OAAAA,WAAoBiB,OAAOjB,EAAAA,OAASsB,MAAMtB,EAAAA,SAAWqB,QAAQrB,EAAAA,QAAUA,EAAAA,UAAY,CAACA,EAAAA,MAAQ,CAACwB,MAAMxB,EAAAA,OAAAA,WAAoByB,KAAKzB,EAAAA,OAASsB,MAAMtB,EAAAA,OAASiB,OAAOjB,EAAAA,OAAAA,aAAsBA,EAAAA,MAAQ,CAACwB,MAAMxB,EAAAA,OAASyB,KAAKzB,EAAAA,OAAAA,WAAoBsB,MAAMtB,EAAAA,OAASiB,OAAOjB,EAAAA,OAAAA,iBAA0B,IAAM6B,EAAE,CAAC,YAAYC,EAAE,SAASjE,GAAM,IAAUG,EAAGH,EAAZuD,SAAcnD,EAAEK,EAAET,EAAEgE,GAAG,OAAO7D,EAAEJ,EAAAA,cAAgBuD,EAAE3D,EAAE,GAAGS,EAAE,CAACmD,SAAS,CAACT,IAAI3C,GAAG,eAAc,EAAGyC,IAAI,MAAM7C,EAAAA,cAAgB,MAAMJ,EAAE,GAAGS,KAAK6D,EAAEF,YAAY,cAAcE,EAAEH,UAAU,CAACP,SAASpB,EAAAA,OAASqB,QAAQ,OAAOnB,EAAEiB,EAAEQ,gBAAW,EAAOzB,EAAEmB,QAAQZ,IAAI,SAAS7C,EAAEC,EAAEG,GAAG,OAAOJ,EAAEC,GAAG,IAAIkE,MAAK,iBAAmBlE,EAAC,kBAAoBG,EAAC,yBAA0B,OAAO,IAAMgE,EAAE,SAASnE,GAAG,OAAOD,EAAAA,cAAgBA,EAAAA,SAAW,KAAKA,EAAAA,cAAgBuD,EAAE3D,EAAE,GAAGK,IAAID,EAAAA,cAAgB,WAAW,KAAKA,EAAAA,cAAgBuD,EAAE3D,EAAE,GAAGK,EAAE,CAACkB,YAAW,QAASiD,EAAEJ,YAAY,YAAYI,EAAEL,UAAUR,EAAEQ,UAAU,IAA8aM,EAAEC,EAA1aC,EAAE,SAACvE,EAAEC,EAAEG,GAAC,2BAAIC,EAAC,iCAADA,EAAC,yBAAGL,EAAE6C,KAAK,KAAK7C,EAAE6C,IAAI2B,IAAAA,OAAAA,MAAAA,IAAC,CAAQxE,EAAEC,EAAEG,GAAC,OAAIC,IAAG,IAAI8D,MAAK,iCAAkC/D,EAAC,4JAA2JqE,EAAE,CAACC,MAAMF,IAAAA,OAAAA,WAAoB3B,IAAI0B,GAAGI,EAAE,CAAC,KAAK,QAAQ,QAAQ,kBAAkB,YAAY,QAAQ,cAAc,SAAS,WAAWC,EAAE,CAAC,QAAQ,aAAaC,EAAE,IAAIC,IAAmBC,EAAG,SAAS/E,GAAG,MAAuGA,EAAnGgF,GAAG/E,OAAC,MAAC,MAAK,EAAOG,EAAkFJ,EAAxF0E,MAAcjD,EAA0EzB,EAAhFoB,MAAwBgB,EAAwDpC,EAAxE0B,gBAA4B8C,EAA4CxE,EAAtDiF,UAAkBC,EAAoClF,EAA1CmF,MAAoBC,EAAsBpF,EAAlCqF,YAAqBC,EAAatF,EAApBuF,OAAiBC,EAAGxF,EAAXyF,QAAaC,EAAEhF,EAAEV,EAAE2E,GAAegB,EAAqBvF,EAA3BuB,MAAeiE,EAAYxF,EAAnBwB,OAAgBiE,EAAGzF,EAAVqC,OAAYqD,EAAE,SAAS9F,EAAEC,EAAEG,GAAG,IAAMC,EAAE,GAAOM,EAAE,uBAAuB,MAAwD,UAAUP,GAAGC,EAAEsB,MAAM3B,EAAEK,EAAEuB,OAAO3B,GAAG,gBAAgBG,IAA0DO,EAAE,yDAAyD,CAACsE,UAAUtE,EAAE,4BAA4B,GAAGS,MAAMf,GAA1U,CAA8UsF,EAAEC,EAAEC,GAAUE,EAAeD,EAArB1E,MAAkB4E,EAAGF,EAAbb,UAAegB,EAAEvF,EAAEoF,EAAElB,GAAGsB,GAAEvF,EAAAA,EAAAA,UAAIwF,GAAEvF,EAAAA,EAAAA,UAAE,kBAAIwF,KAAKC,UAAUjG,EAAEkG,UAAQ,CAAClG,EAAEkG,SAASpB,IAAIV,EAAEU,GAAG,IAAMqB,EAAE,SAASvG,EAAEC,EAAEG,GAAG,IAAIC,EAAE,GAAG,MAAM,cAAcL,IAAIK,EAAC,+CAAgDD,EAAEH,EAAE,IAAG,cAAc,gBAAgBD,IAAIK,EAAC,0BAA2BJ,EAAC,iIAAgIG,EAAC,YAAYH,EAAC,yIAAsII,EAA5b,CAA+bwF,EAAEF,EAAEC,GAAG,OAAOrE,EAAAA,EAAAA,YAAE,WAAK8C,IAAIA,EAAE,sDAAqCmC,MAAK,gBAAsBxG,EAAC,EAArByG,oBAA2CxG,EAAC,EAAtByG,qBAAoB,OAAOpC,EAAGtE,EAAE,CAACyG,oBAAoBzG,EAAE0G,qBAAqBzG,OAAM,IAAubA,EAAEI,EAAnbL,EAAEkG,EAAES,QAAQC,cAAc,2BAA2B,OAAG5G,GAAGe,KAAWf,EAAE6G,UAAU,MAAMzB,GAAGA,EAAE,CAAC0B,WAAU,IAAK,MAAMxB,GAAGA,EAAE,CAACwB,WAAU,IAAKC,YAAW,WAAK/G,EAAEgH,gBAAgB,2BAA0B,KAAK,MAAM5B,GAAGA,EAAE,CAAC0B,WAAU,IAAK9G,EAAEiH,iBAAiB,QAAO,SAAShH,IAAID,EAAEkH,oBAAoB,OAAOjH,GAAG,MAAMqF,GAAGA,EAAE,CAACwB,WAAU,IAAKC,YAAW,WAAK/G,EAAEgH,gBAAgB,2BAA0B,YAAWnC,EAAEsC,IAAIhB,IAAM7B,GAAIO,EAAEuC,IAAIjB,QAAb,GAAsC9B,EAAEmC,MAAK,YAAkD,IAA5BxG,EAAC,EAArByG,oBAA2C9F,EAAC,EAAtB+F,qBAA2BR,EAAES,UAAUT,EAAES,QAAQU,UAAUrH,EAAEJ,EAAE,CAAC0H,WAAU,EAAGC,SAAS1C,EAAEuC,IAAIjB,GAAGzB,MAAMtE,GAAGsF,IAAIb,EAAEuC,IAAIjB,KAAKlG,EAAEuH,uBAAsB,WAAKtB,EAAES,UAAUtG,EAAEM,EAAEuF,EAAES,QAAQR,EAAEtB,EAAEpD,EAAE2D,EAAEE,EAAEE,YAAU,WAAKvF,GAAGwH,qBAAqBxH,GAAGI,GAAGA,QAAM,CAACD,KAAIoB,EAAAA,EAAAA,kBAAE,WAAKqD,EAAEuC,IAAIjB,IAAI7B,IAAK4B,EAAES,QAAQU,UAAU/C,EAAG1E,EAAE,CAAC0H,UAAUzC,EAAEuC,IAAIjB,GAAGoB,SAAS1C,EAAEuC,IAAIjB,GAAGzB,MAAMtE,GAAGsF,IAAI,MAAMN,GAAGA,EAAE,CAAC0B,WAAU,IAAK,MAAMxB,GAAGA,EAAE,CAACwB,WAAU,OAAO,CAAC1G,KAAIC,EAAAA,EAAAA,eAAEJ,EAAEL,EAAE,GAAGqG,EAAE,CAAC7E,MAAMxB,EAAE,GAAGmG,EAAEtE,EAAE,CAACC,gBAAgBU,IAAI6C,UAAae,GAAIxB,EAAC,IAAKA,EAAI,IAAKkD,IAAIxB,EAAEyB,wBAAwB,CAACC,OAAOrB,GAAGsB,0BAAyB,MAAOC,GAAG1H,EAAAA,EAAAA,OAAE,SAASJ,GAAG,OAAOA,EAAE0E,OAAyMrE,EAAAA,EAAAA,eAAE0E,EAAG/E,GAAoG,QAAQ8H,EAAG/D,UAAUU,EAAEqD,EAAG9D,YAAY,cAAc,IAAovB/D,EAA9uB8H,EAAG,CAAC,MAAM,cAAc,UAAU,QAAQ,SAAS,cAAc,mBAAmB,cAAc,UAAU,UAAU,mBAAmB,aAAa,aAAa,cAAc,cAAc,iBAAiB,cAAc,wBAAwBC,EAAG,SAAChI,EAAEC,GAAC,2BAAIG,EAAC,iCAADA,EAAC,wBAAG,cAAcJ,EAAEyC,QAAQ,UAAUxC,GAAG,WAAWA,IAAID,EAAEC,GAAGuE,IAAAA,OAAAA,MAAAA,IAAC,CAAQxE,EAAEC,GAAC,OAAIG,IAAG,IAAI+D,MAAK,IAAKlE,EAAC,KAAKD,EAAEC,GAAE,iDAAgDgI,EAAG,IAAInD,IAAI,CAAC,QAAQ,YAAY,gBAAgBoD,EAAG,CAACnF,IAAIyB,IAAAA,OAAAA,WAAoB3B,IAAI0B,EAAE5C,MAAMqG,EAAGpG,OAAOoG,EAAGtE,MAAMc,IAAAA,OAAS/B,OAAO,SAAAzC,GAAI,QAAG,IAASA,EAAEyC,SAASwF,EAAGb,IAAIpH,EAAEyC,QAAQ,OAAO,IAAI0B,MAAK,iBAAkBnE,EAAEyC,OAAM,wHAAwH0F,GAAYlI,EAA2X6H,EAAjX,SAAS1H,GAAG,IAAQC,EAA2BD,EAA/B2C,IAAkBpC,EAAaP,EAAzBgI,YAAsBxH,EAAGR,EAAXiI,QAAa9G,EAAEb,EAAEN,EAAE2H,GAAI,OAAOnH,GAAG0H,QAAQC,KAAK3H,GAAGD,EAAEX,EAAAA,cAAgBC,EAAEL,EAAE,CAAC8E,MAAM/D,GAAGY,KAAK+G,QAAQC,KAAK,mBAAmBlI,GAA+M,QAAY8H,EAAGnE,YAAY,cAAcmE,EAAGpE,UAAUmE,G,iBCEn+e,IA6BMzH,EAAY,SAAC+H,EAAOlD,GACzB,GAAuB,iBAAVkD,IAAsB/E,MAAMgF,QAAQD,GAChD,MAAM,IAAIE,UAAU,gDAGrBpD,EAAUO,OAAO8C,OAAO,CACvBC,YAAY,GACVtD,GAEH,IAAoBuD,EAUpB,OAPCL,EADG/E,MAAMgF,QAAQD,GACTA,EAAMM,KAAI,SAAAD,GAAC,OAAIA,EAAEE,UACvBnH,QAAO,SAAAiH,GAAC,OAAIA,EAAErE,UACdwE,KAAK,KAECR,EAAMO,OAGM,IAAjBP,EAAMhE,OACF,GAGa,IAAjBgE,EAAMhE,OACFc,EAAQsD,WAAaJ,EAAMS,cAAgBT,EAAMhI,eAGpCgI,IAAUA,EAAMhI,gBAGpCgI,EA3DwB,SAAAvE,GAKzB,IAJA,IAAIiF,GAAkB,EAClBC,GAAkB,EAClBC,GAAsB,EAEjBC,EAAI,EAAGA,EAAIpF,EAAOO,OAAQ6E,IAAK,CACvC,IAAMC,EAAYrF,EAAOoF,GAErBH,GAAmB,WAAWK,KAAKD,IAAcA,EAAUL,gBAAkBK,GAChFrF,EAASA,EAAOxC,MAAM,EAAG4H,GAAK,IAAMpF,EAAOxC,MAAM4H,GACjDH,GAAkB,EAClBE,EAAsBD,EACtBA,GAAkB,EAClBE,KACUF,GAAmBC,GAAuB,WAAWG,KAAKD,IAAcA,EAAU9I,gBAAkB8I,GAC9GrF,EAASA,EAAOxC,MAAM,EAAG4H,EAAI,GAAK,IAAMpF,EAAOxC,MAAM4H,EAAI,GACzDD,EAAsBD,EACtBA,GAAkB,EAClBD,GAAkB,IAElBA,EAAkBI,EAAU9I,gBAAkB8I,GAAaA,EAAUL,gBAAkBK,EACvFF,EAAsBD,EACtBA,EAAkBG,EAAUL,gBAAkBK,GAAaA,EAAU9I,gBAAkB8I,GAIzF,OAAOrF,EAiCEuF,CAAkBhB,IAG3BA,EAAQA,EACNiB,QAAQ,YAAa,IACrBjJ,cACAiJ,QAAQ,mBAAmB,SAACC,EAAGC,GAAE,OAAKA,EAAGV,iBACzCQ,QAAQ,cAAc,SAAAG,GAAC,OAAIA,EAAEX,iBA5BXJ,EA8BDL,EA9BMlD,EAAQsD,WAAaC,EAAEgB,OAAO,GAAGZ,cAAgBJ,EAAEpH,MAAM,GAAKoH,IAiCxFiB,EAAOC,QAAUtJ,EAEjBqJ,EAAOC,QAAPD,QAAyBrJ,G,uDCzBzB,IAvCY,WAAO,IAAD,EAeVuJ,EAA+B,QAAzB,GAdCC,EAAAA,EAAAA,gBAAe,cAcRC,KAAKC,oBAAY,aAAtB,EAAwBH,OAEvC,OACE,uBAAK5D,UAAU,OACb,gBAAC,EAAAgE,EAAW,CACVhE,UAAU,aACVvG,OAAO,QACPS,QAAS,CAAC,OAAQ,OAAQ,QAC1B+J,IAAI,4BACJzJ,MAAO,GACPd,OAAQ,GACRwK,QAAS,GACTnH,IAAI,kBAAiB,uBAEtB6G,MAAAA,OAAM,EAANA,EAAQO,OACP,uCACa,8BAASP,EAAOO,MAAc,KAAEP,MAAAA,OAAM,EAANA,EAAQQ,UAAW,KAC9D,+B","sources":["webpack://gatsby-starter-blog/../src/image-utils.ts","webpack://gatsby-starter-blog/./node_modules/gatsby-plugin-image/node_modules/camelcase/index.js","webpack://gatsby-starter-blog/./src/components/bio.js"],"sourcesContent":["import camelCase from \"camelcase\"\nimport type { IGatsbyImageData } from \"./index\"\n\nconst DEFAULT_PIXEL_DENSITIES = [0.25, 0.5, 1, 2]\nexport const DEFAULT_BREAKPOINTS = [750, 1080, 1366, 1920]\nexport const EVERY_BREAKPOINT = [\n  320, 654, 768, 1024, 1366, 1600, 1920, 2048, 2560, 3440, 3840, 4096,\n]\nconst DEFAULT_FLUID_WIDTH = 800\nconst DEFAULT_FIXED_WIDTH = 800\nconst DEFAULT_ASPECT_RATIO = 4 / 3\n\nexport type Fit = \"cover\" | \"fill\" | \"inside\" | \"outside\" | \"contain\"\n\nexport type Layout = \"fixed\" | \"fullWidth\" | \"constrained\"\nexport type ImageFormat = \"jpg\" | \"png\" | \"webp\" | \"avif\" | \"auto\" | \"\"\n\n/**\n * The minimal required reporter, as we don't want to import it from gatsby-cli\n */\nexport interface IReporter {\n  warn(message: string): void\n}\n\nexport interface ISharpGatsbyImageArgs {\n  layout?: Layout\n  formats?: Array<ImageFormat>\n  placeholder?: \"tracedSVG\" | \"dominantColor\" | \"blurred\" | \"none\"\n  tracedSVGOptions?: Record<string, unknown>\n  width?: number\n  height?: number\n  aspectRatio?: number\n  sizes?: string\n  quality?: number\n  transformOptions?: {\n    fit?: Fit\n    cropFocus?: number | string\n    duotone?: {\n      highlight: string\n      shadow: string\n      opacity?: number\n    }\n    grayscale?: boolean\n    rotate?: number\n    trim?: number\n  }\n  jpgOptions?: Record<string, unknown>\n  pngOptions?: Record<string, unknown>\n  webpOptions?: Record<string, unknown>\n  avifOptions?: Record<string, unknown>\n  blurredOptions?: { width?: number; toFormat?: ImageFormat }\n  breakpoints?: Array<number>\n  outputPixelDensities?: Array<number>\n  backgroundColor?: string\n}\n\nexport interface IImageSizeArgs {\n  width?: number\n  height?: number\n  layout?: Layout\n  filename: string\n  outputPixelDensities?: Array<number>\n  breakpoints?: Array<number>\n  fit?: Fit\n  reporter?: IReporter\n  sourceMetadata: { width: number; height: number }\n}\n\nexport interface IImageSizes {\n  sizes: Array<number>\n  presentationWidth: number\n  presentationHeight: number\n  aspectRatio: number\n  unscaledWidth: number\n}\n\nexport interface IImage {\n  src: string\n  width: number\n  height: number\n  format: ImageFormat\n}\n\nexport interface IGatsbyImageHelperArgs {\n  pluginName: string\n  generateImageSource: (\n    filename: string,\n    width: number,\n    height: number,\n    format: ImageFormat,\n    fit?: Fit,\n    options?: Record<string, unknown>\n  ) => IImage\n  layout?: Layout\n  formats?: Array<ImageFormat>\n  filename: string\n  placeholderURL?: string\n  width?: number\n  height?: number\n  sizes?: string\n  reporter?: IReporter\n  sourceMetadata?: { width: number; height: number; format: ImageFormat }\n  fit?: Fit\n  options?: Record<string, unknown>\n  breakpoints?: Array<number>\n  backgroundColor?: string\n  aspectRatio?: number\n}\n\nconst warn = (message: string): void => console.warn(message)\n\nconst sortNumeric = (a: number, b: number): number => a - b\n\nexport const getSizes = (width: number, layout: Layout): string | undefined => {\n  switch (layout) {\n    // If screen is wider than the max size, image width is the max size,\n    // otherwise it's the width of the screen\n    case `constrained`:\n      return `(min-width: ${width}px) ${width}px, 100vw`\n\n    // Image is always the same width, whatever the size of the screen\n    case `fixed`:\n      return `${width}px`\n\n    // Image is always the width of the screen\n    case `fullWidth`:\n      return `100vw`\n\n    default:\n      return undefined\n  }\n}\n\nexport const getSrcSet = (images: Array<IImage>): string =>\n  images.map(image => `${image.src} ${image.width}w`).join(`,\\n`)\n\nexport function formatFromFilename(filename: string): ImageFormat | undefined {\n  const dot = filename.lastIndexOf(`.`)\n  if (dot !== -1) {\n    const ext = filename.slice(dot + 1)\n    if (ext === `jpeg`) {\n      return `jpg`\n    }\n    if (ext.length === 3 || ext.length === 4) {\n      return ext as ImageFormat\n    }\n  }\n  return undefined\n}\n\nexport function setDefaultDimensions(\n  args: IGatsbyImageHelperArgs\n): IGatsbyImageHelperArgs {\n  let {\n    layout = `constrained`,\n    width,\n    height,\n    sourceMetadata,\n    breakpoints,\n    aspectRatio,\n    formats = [`auto`, `webp`],\n  } = args\n  formats = formats.map(format => format.toLowerCase() as ImageFormat)\n  layout = camelCase(layout) as Layout\n\n  if (width && height) {\n    return { ...args, formats, layout, aspectRatio: width / height }\n  }\n  if (sourceMetadata.width && sourceMetadata.height && !aspectRatio) {\n    aspectRatio = sourceMetadata.width / sourceMetadata.height\n  }\n\n  if (layout === `fullWidth`) {\n    width = width || sourceMetadata.width || breakpoints[breakpoints.length - 1]\n    height = height || Math.round(width / (aspectRatio || DEFAULT_ASPECT_RATIO))\n  } else {\n    if (!width) {\n      if (height && aspectRatio) {\n        width = height * aspectRatio\n      } else if (sourceMetadata.width) {\n        width = sourceMetadata.width\n      } else if (height) {\n        width = Math.round(height / DEFAULT_ASPECT_RATIO)\n      } else {\n        width = DEFAULT_FIXED_WIDTH\n      }\n    }\n\n    if (aspectRatio && !height) {\n      height = Math.round(width / aspectRatio)\n    } else if (!aspectRatio) {\n      aspectRatio = width / height\n    }\n  }\n  return { ...args, width, height, aspectRatio, layout, formats }\n}\n\n/**\n * Use this for getting an image for the blurred placeholder. This ensures the\n * aspect ratio and crop match the main image\n */\nexport function getLowResolutionImageURL(\n  args: IGatsbyImageHelperArgs,\n  width = 20\n): string {\n  args = setDefaultDimensions(args)\n  const { generateImageSource, filename, aspectRatio } = args\n  return generateImageSource(\n    filename,\n    width,\n    Math.round(width / aspectRatio),\n    args.sourceMetadata.format || `jpg`,\n    args.fit,\n    args.options\n  )?.src\n}\n\nexport function generateImageData(\n  args: IGatsbyImageHelperArgs\n): IGatsbyImageData {\n  args = setDefaultDimensions(args)\n\n  let {\n    pluginName,\n    sourceMetadata,\n    generateImageSource,\n    layout,\n    fit,\n    options,\n    width,\n    height,\n    filename,\n    reporter = { warn },\n    backgroundColor,\n    placeholderURL,\n  } = args\n\n  if (!pluginName) {\n    reporter.warn(\n      `[gatsby-plugin-image] \"generateImageData\" was not passed a plugin name`\n    )\n  }\n\n  if (typeof generateImageSource !== `function`) {\n    throw new Error(`generateImageSource must be a function`)\n  }\n\n  if (!sourceMetadata || (!sourceMetadata.width && !sourceMetadata.height)) {\n    // No metadata means we let the CDN handle max size etc, aspect ratio etc\n    sourceMetadata = {\n      width,\n      height,\n      format: sourceMetadata?.format || formatFromFilename(filename) || `auto`,\n    }\n  } else if (!sourceMetadata.format) {\n    sourceMetadata.format = formatFromFilename(filename)\n  }\n\n  const formats = new Set<ImageFormat>(args.formats)\n\n  if (formats.size === 0 || formats.has(`auto`) || formats.has(``)) {\n    formats.delete(`auto`)\n    formats.delete(``)\n    formats.add(sourceMetadata.format)\n  }\n\n  if (formats.has(`jpg`) && formats.has(`png`)) {\n    reporter.warn(\n      `[${pluginName}] Specifying both 'jpg' and 'png' formats is not supported. Using 'auto' instead`\n    )\n    if (sourceMetadata.format === `jpg`) {\n      formats.delete(`png`)\n    } else {\n      formats.delete(`jpg`)\n    }\n  }\n\n  const imageSizes = calculateImageSizes({ ...args, sourceMetadata })\n\n  const result: IGatsbyImageData[\"images\"] = {\n    sources: [],\n  }\n\n  let sizes = args.sizes\n  if (!sizes) {\n    sizes = getSizes(imageSizes.presentationWidth, layout)\n  }\n\n  formats.forEach(format => {\n    const images = imageSizes.sizes\n      .map(size => {\n        const imageSrc = generateImageSource(\n          filename,\n          size,\n          Math.round(size / imageSizes.aspectRatio),\n          format,\n          fit,\n          options\n        )\n        if (\n          !imageSrc?.width ||\n          !imageSrc.height ||\n          !imageSrc.src ||\n          !imageSrc.format\n        ) {\n          reporter.warn(\n            `[${pluginName}] The resolver for image ${filename} returned an invalid value.`\n          )\n          return undefined\n        }\n        return imageSrc\n      })\n      .filter(Boolean)\n\n    if (format === `jpg` || format === `png` || format === `auto`) {\n      const unscaled =\n        images.find(img => img.width === imageSizes.unscaledWidth) || images[0]\n\n      if (unscaled) {\n        result.fallback = {\n          src: unscaled.src,\n          srcSet: getSrcSet(images),\n          sizes,\n        }\n      }\n    } else {\n      result.sources?.push({\n        srcSet: getSrcSet(images),\n        sizes,\n        type: `image/${format}`,\n      })\n    }\n  })\n\n  const imageProps: Partial<IGatsbyImageData> = {\n    images: result,\n    layout,\n    backgroundColor,\n  }\n\n  if (placeholderURL) {\n    imageProps.placeholder = { fallback: placeholderURL }\n  }\n\n  switch (layout) {\n    case `fixed`:\n      imageProps.width = imageSizes.presentationWidth\n      imageProps.height = imageSizes.presentationHeight\n      break\n\n    case `fullWidth`:\n      imageProps.width = 1\n      imageProps.height = 1 / imageSizes.aspectRatio\n      break\n\n    case `constrained`:\n      imageProps.width = args.width || imageSizes.presentationWidth || 1\n      imageProps.height = (imageProps.width || 1) / imageSizes.aspectRatio\n  }\n\n  return imageProps as IGatsbyImageData\n}\n\nconst dedupeAndSortDensities = (values: Array<number>): Array<number> =>\n  Array.from(new Set([1, ...values])).sort(sortNumeric)\n\nexport function calculateImageSizes(args: IImageSizeArgs): IImageSizes {\n  const {\n    width,\n    height,\n    filename,\n    layout = `constrained`,\n    sourceMetadata: imgDimensions,\n    reporter = { warn },\n    breakpoints = DEFAULT_BREAKPOINTS,\n  } = args\n\n  // check that all dimensions provided are positive\n  const userDimensions = { width, height }\n  const erroneousUserDimensions = Object.entries(userDimensions).filter(\n    ([_, size]) => typeof size === `number` && size < 1\n  )\n  if (erroneousUserDimensions.length) {\n    throw new Error(\n      `Specified dimensions for images must be positive numbers (> 0). Problem dimensions you have are ${erroneousUserDimensions\n        .map(dim => dim.join(`: `))\n        .join(`, `)}`\n    )\n  }\n\n  if (layout === `fixed`) {\n    return fixedImageSizes(args)\n  } else if (layout === `constrained`) {\n    return responsiveImageSizes(args)\n  } else if (layout === `fullWidth`) {\n    return responsiveImageSizes({ breakpoints, ...args })\n  } else {\n    reporter.warn(\n      `No valid layout was provided for the image at ${filename}. Valid image layouts are fixed, fullWidth, and constrained. Found ${layout}`\n    )\n    return {\n      sizes: [imgDimensions.width],\n      presentationWidth: imgDimensions.width,\n      presentationHeight: imgDimensions.height,\n      aspectRatio: imgDimensions.width / imgDimensions.height,\n      unscaledWidth: imgDimensions.width,\n    }\n  }\n}\nexport function fixedImageSizes({\n  filename,\n  sourceMetadata: imgDimensions,\n  width,\n  height,\n  fit = `cover`,\n  outputPixelDensities = DEFAULT_PIXEL_DENSITIES,\n  reporter = { warn },\n}: IImageSizeArgs): IImageSizes {\n  let aspectRatio = imgDimensions.width / imgDimensions.height\n  // Sort, dedupe and ensure there's a 1\n  const densities = dedupeAndSortDensities(outputPixelDensities)\n\n  // If both are provided then we need to check the fit\n  if (width && height) {\n    const calculated = getDimensionsAndAspectRatio(imgDimensions, {\n      width,\n      height,\n      fit,\n    })\n    width = calculated.width\n    height = calculated.height\n    aspectRatio = calculated.aspectRatio\n  }\n\n  if (!width) {\n    if (!height) {\n      width = DEFAULT_FIXED_WIDTH\n    } else {\n      width = Math.round(height * aspectRatio)\n    }\n  } else if (!height) {\n    height = Math.round(width / aspectRatio)\n  }\n\n  const originalWidth = width // will use this for presentationWidth, don't want to lose it\n  const isTopSizeOverriden =\n    imgDimensions.width < width || imgDimensions.height < (height as number)\n\n  // If the image is smaller than requested, warn the user that it's being processed as such\n  // print out this message with the necessary information before we overwrite it for sizing\n  if (isTopSizeOverriden) {\n    const fixedDimension = imgDimensions.width < width ? `width` : `height`\n    reporter.warn(`\nThe requested ${fixedDimension} \"${\n      fixedDimension === `width` ? width : height\n    }px\" for the image ${filename} was larger than the actual image ${fixedDimension} of ${\n      imgDimensions[fixedDimension]\n    }px. If possible, replace the current image with a larger one.`)\n\n    if (fixedDimension === `width`) {\n      width = imgDimensions.width\n      height = Math.round(width / aspectRatio)\n    } else {\n      height = imgDimensions.height\n      width = height * aspectRatio\n    }\n  }\n\n  const sizes = densities\n    .filter(size => size >= 1) // remove smaller densities because fixed images don't need them\n    .map(density => Math.round(density * (width as number)))\n    .filter(size => size <= imgDimensions.width)\n\n  return {\n    sizes,\n    aspectRatio,\n    presentationWidth: originalWidth,\n    presentationHeight: Math.round(originalWidth / aspectRatio),\n    unscaledWidth: width,\n  }\n}\n\nexport function responsiveImageSizes({\n  sourceMetadata: imgDimensions,\n  width,\n  height,\n  fit = `cover`,\n  outputPixelDensities = DEFAULT_PIXEL_DENSITIES,\n  breakpoints,\n  layout,\n}: IImageSizeArgs): IImageSizes {\n  let sizes\n  let aspectRatio = imgDimensions.width / imgDimensions.height\n  // Sort, dedupe and ensure there's a 1\n  const densities = dedupeAndSortDensities(outputPixelDensities)\n\n  // If both are provided then we need to check the fit\n  if (width && height) {\n    const calculated = getDimensionsAndAspectRatio(imgDimensions, {\n      width,\n      height,\n      fit,\n    })\n    width = calculated.width\n    height = calculated.height\n    aspectRatio = calculated.aspectRatio\n  }\n\n  // Case 1: width of height were passed in, make sure it isn't larger than the actual image\n  width = width && Math.min(width, imgDimensions.width)\n  height = height && Math.min(height, imgDimensions.height)\n\n  // Case 2: neither width or height were passed in, use default size\n  if (!width && !height) {\n    width = Math.min(DEFAULT_FLUID_WIDTH, imgDimensions.width)\n    height = width / aspectRatio\n  }\n\n  // if it still hasn't been found, calculate width from the derived height.\n  // TS isn't smart enough to realise the type for height has been narrowed here\n  if (!width) {\n    width = (height as number) * aspectRatio\n  }\n\n  const originalWidth = width\n  const isTopSizeOverriden =\n    imgDimensions.width < width || imgDimensions.height < (height as number)\n  if (isTopSizeOverriden) {\n    width = imgDimensions.width\n    height = imgDimensions.height\n  }\n\n  width = Math.round(width)\n\n  if (breakpoints?.length > 0) {\n    sizes = breakpoints.filter(size => size <= imgDimensions.width)\n\n    // If a larger breakpoint has been filtered-out, add the actual image width instead\n    if (\n      sizes.length < breakpoints.length &&\n      !sizes.includes(imgDimensions.width)\n    ) {\n      sizes.push(imgDimensions.width)\n    }\n  } else {\n    sizes = densities.map(density => Math.round(density * (width as number)))\n    sizes = sizes.filter(size => size <= imgDimensions.width)\n  }\n\n  // ensure that the size passed in is included in the final output\n  if (layout === `constrained` && !sizes.includes(width)) {\n    sizes.push(width)\n  }\n  sizes = sizes.sort(sortNumeric)\n  return {\n    sizes,\n    aspectRatio,\n    presentationWidth: originalWidth,\n    presentationHeight: Math.round(originalWidth / aspectRatio),\n    unscaledWidth: width,\n  }\n}\n\nexport function getDimensionsAndAspectRatio(\n  dimensions,\n  options\n): { width: number; height: number; aspectRatio: number } {\n  // Calculate the eventual width/height of the image.\n  const imageAspectRatio = dimensions.width / dimensions.height\n\n  let width = options.width\n  let height = options.height\n\n  switch (options.fit) {\n    case `fill`: {\n      width = options.width ? options.width : dimensions.width\n      height = options.height ? options.height : dimensions.height\n      break\n    }\n    case `inside`: {\n      const widthOption = options.width\n        ? options.width\n        : Number.MAX_SAFE_INTEGER\n      const heightOption = options.height\n        ? options.height\n        : Number.MAX_SAFE_INTEGER\n\n      width = Math.min(widthOption, Math.round(heightOption * imageAspectRatio))\n      height = Math.min(\n        heightOption,\n        Math.round(widthOption / imageAspectRatio)\n      )\n      break\n    }\n    case `outside`: {\n      const widthOption = options.width ? options.width : 0\n      const heightOption = options.height ? options.height : 0\n\n      width = Math.max(widthOption, Math.round(heightOption * imageAspectRatio))\n      height = Math.max(\n        heightOption,\n        Math.round(widthOption / imageAspectRatio)\n      )\n      break\n    }\n\n    default: {\n      if (options.width && !options.height) {\n        width = options.width\n        height = Math.round(options.width / imageAspectRatio)\n      }\n\n      if (options.height && !options.width) {\n        width = Math.round(options.height * imageAspectRatio)\n        height = options.height\n      }\n    }\n  }\n\n  return {\n    width,\n    height,\n    aspectRatio: width / height,\n  }\n}\n","'use strict';\n\nconst preserveCamelCase = string => {\n\tlet isLastCharLower = false;\n\tlet isLastCharUpper = false;\n\tlet isLastLastCharUpper = false;\n\n\tfor (let i = 0; i < string.length; i++) {\n\t\tconst character = string[i];\n\n\t\tif (isLastCharLower && /[a-zA-Z]/.test(character) && character.toUpperCase() === character) {\n\t\t\tstring = string.slice(0, i) + '-' + string.slice(i);\n\t\t\tisLastCharLower = false;\n\t\t\tisLastLastCharUpper = isLastCharUpper;\n\t\t\tisLastCharUpper = true;\n\t\t\ti++;\n\t\t} else if (isLastCharUpper && isLastLastCharUpper && /[a-zA-Z]/.test(character) && character.toLowerCase() === character) {\n\t\t\tstring = string.slice(0, i - 1) + '-' + string.slice(i - 1);\n\t\t\tisLastLastCharUpper = isLastCharUpper;\n\t\t\tisLastCharUpper = false;\n\t\t\tisLastCharLower = true;\n\t\t} else {\n\t\t\tisLastCharLower = character.toLowerCase() === character && character.toUpperCase() !== character;\n\t\t\tisLastLastCharUpper = isLastCharUpper;\n\t\t\tisLastCharUpper = character.toUpperCase() === character && character.toLowerCase() !== character;\n\t\t}\n\t}\n\n\treturn string;\n};\n\nconst camelCase = (input, options) => {\n\tif (!(typeof input === 'string' || Array.isArray(input))) {\n\t\tthrow new TypeError('Expected the input to be `string | string[]`');\n\t}\n\n\toptions = Object.assign({\n\t\tpascalCase: false\n\t}, options);\n\n\tconst postProcess = x => options.pascalCase ? x.charAt(0).toUpperCase() + x.slice(1) : x;\n\n\tif (Array.isArray(input)) {\n\t\tinput = input.map(x => x.trim())\n\t\t\t.filter(x => x.length)\n\t\t\t.join('-');\n\t} else {\n\t\tinput = input.trim();\n\t}\n\n\tif (input.length === 0) {\n\t\treturn '';\n\t}\n\n\tif (input.length === 1) {\n\t\treturn options.pascalCase ? input.toUpperCase() : input.toLowerCase();\n\t}\n\n\tconst hasUpperCase = input !== input.toLowerCase();\n\n\tif (hasUpperCase) {\n\t\tinput = preserveCamelCase(input);\n\t}\n\n\tinput = input\n\t\t.replace(/^[_.\\- ]+/, '')\n\t\t.toLowerCase()\n\t\t.replace(/[_.\\- ]+(\\w|$)/g, (_, p1) => p1.toUpperCase())\n\t\t.replace(/\\d+(\\w|$)/g, m => m.toUpperCase());\n\n\treturn postProcess(input);\n};\n\nmodule.exports = camelCase;\n// TODO: Remove this for the next major release\nmodule.exports.default = camelCase;\n","/**\n * Bio component that queries for data\n * with Gatsby's useStaticQuery component\n *\n * See: https://www.gatsbyjs.com/docs/use-static-query/\n */\n\nimport * as React from \"react\"\nimport { useStaticQuery, graphql } from \"gatsby\"\nimport { StaticImage } from \"gatsby-plugin-image\"\n\nconst Bio = () => {\n  const data = useStaticQuery(graphql`\n    query BioQuery {\n      site {\n        siteMetadata {\n          author {\n            name\n            summary\n          }\n        }\n      }\n    }\n  `)\n\n  // Set these values by editing \"siteMetadata\" in gatsby-config.js\n  const author = data.site.siteMetadata?.author\n\n  return (\n    <div className=\"bio\">\n      <StaticImage\n        className=\"bio-avatar\"\n        layout=\"fixed\"\n        formats={[\"auto\", \"webp\", \"avif\"]}\n        src=\"../images/profile-pic.png\"\n        width={50}\n        height={50}\n        quality={95}\n        alt=\"Profile picture\"\n      />\n      {author?.name && (\n        <p>\n          Written by <strong>{author.name}</strong> {author?.summary || null}\n          <br />\n        </p>\n      )}\n    </div>\n  )\n}\n\nexport default Bio\n"],"names":["args","layout","height","sourceMetadata","message","console","breakpoints","aspectRatio","a","images","formats","format","toLowerCase","camelCase","Math","image","width","round","setDefaultDimensions","widthOption","gatsbyImage","props","left","position","top","transform","transition","filename","dot","slice","calculateImageSizes","has","filter","isLoading","isLoaded","EVERY_BREAKPOINT","willChange","shouldLoad","opacity","objectFit","ext","style","H","media","process","entries","env","NODE_ENV","output","source","paddingTop","size","maxWidth","display","React","alt","role","dimensions","children","Fragment","includes","Array","push","formatFromFilename","wrapperStyle","MAX_SAFE_INTEGER","Sizer","t","key","string","isRequired","imageSizes","bool","_Picture$propTypes","propName","Picture","length","displayName","bottom","arrayOf","oneOfType","Placeholder","forEach","componentName","MainImage","rest","generateImageSource","object","fit","altValidator","options","te","_generateImageSource","e","backgroundColor","placeholderURL","add","Object","calculated","originalWidth","srcSet","values","getSrcSet","k","className","preactClass","heightOption","from","class","onStartLoad","onLoad","overflow","verticalAlign","getWrapperProps","wStyle","wClass","wrapperProps","useRef","useMemo","img","Boolean","JSON","stringify","sizer","getSizer","useEffect","renderImageToStringPromise","import","then","renderImageToString","swapPlaceholderImage","renderImage","root","querySelector","ssrImage","hasNativeLazyLoadSupport","complete","wasCached","pluginName","reporter","input","isArray","TypeError","assign","pascalCase","x","map","trim","join","toUpperCase","isLastCharLower","isLastCharUpper","isLastLastCharUpper","i","character","test","preserveCamelCase","replace","_","p1","m","charAt","module","exports","author","useStaticQuery","site","siteMetadata","S","src","quality","name","summary"],"sourceRoot":""}